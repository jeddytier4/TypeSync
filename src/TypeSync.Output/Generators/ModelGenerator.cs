using System.Collections.Generic;
using System.Linq;
using System.Text;
using log4net;
using TypeSync.Common.Utilities;
using TypeSync.Models.Common;
using TypeSync.Models.TypeScript;

namespace TypeSync.Output.Generators
{
    public class ModelGenerator : GeneratorBase
    {
        private static readonly ILog log = LogManager.GetLogger(typeof(ModelGenerator));

        public string GenerateClass(TypeScriptClassModel classModel, bool includeHeader = true)
        {
            var sb = new StringBuilder();

            if (includeHeader)
            {
                sb.Append(AutogeneratedHeader_Compact());
            }

            var typeGenerator = new TypeGenerator();

            // imports
            GenerateImportDeclarations(classModel.Imports, sb);         

            // class declaration
            sb.AppendLine("export class "
                + classModel.Name
                + (classModel.IsGeneric ? $"<{GenerateTypeParameters(classModel.TypeParameters)}>" : "")
                + (string.IsNullOrEmpty(classModel.BaseClass) ? "" : " extends " + classModel.BaseClass)
                + " {");

            // properties
            foreach (var property in classModel.Properties)
            {
                var emittedType = typeGenerator.GetEmittedType(property.Type);

                sb.AppendLine("\t"                                  // indentation
                    + NameCaseConverter.ToCamelCase(property.Name)  // property name
                    + (property.IsOptional ? "?" : "")              // optional?
                    + ": "
                    + emittedType                                   // property type
                    + ";");
            }

            sb.AppendLine("}");
            // sb.AppendLine();

            return sb.ToString();
        }

        public string GenerateEnum(TypeScriptEnumModel enumModel, bool includeHeader = true)
        {
            var sb = new StringBuilder();

            if (includeHeader)
            {
                sb.Append(AutogeneratedHeader_Compact());
            }           

            // enums have no imports

            // enum declaration
            sb.AppendLine("export enum " + enumModel.Name + " {");

            // members
            for (int i = 0; i < enumModel.Members.Count; i++)
            {
                var member = enumModel.Members[i];

                sb.AppendLine("\t"                                              // indentation
                    + member.Name                                               // member name
                    + (member.Value.HasValue ? $" = {member.Value.Value}" : "") // optional constant value
                    + (i == enumModel.Members.Count - 1 ? "" : ","));           // skip comma if last value
            }

            sb.AppendLine("}");
            // sb.AppendLine();

            return sb.ToString();
        }
    }
}
